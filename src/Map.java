package starfleet;


import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by BChilds on 1/27/17.
 */
public class Map {
    /*
    This class:
    - generates a map to output
    - Processes moves and actions
    - checks starfleet.Mine states and ship position
    - generates new map to output
    - iterates to next move/action

    Takes in a list of commands and a list of Mines, uses this to generate map size and ship coordinates
        A movement is actually a change in map size, as ship is always center of the map
    */

    //starfleet.Map HAS A list of mines generated by starfleet.Inputs

    //Elements public for unit testing, rather than making getter methods
    public ArrayList<Mine> mineArrayList = new ArrayList<>();
    public ArrayList<String> commandArrayList = new ArrayList<>();
    public int[] mapDimension = new int[2];
    int[][] alpha = new int[][] {{-1,-1},{-1,1},{1,-1},{1,1}};
    int[][] beta = new int[][] {{-1,0},{0,-1},{1,0},{0,1}};
    int[][] gamma = new int[][] {{-1,0},{0,0},{1,0}};
    int[][] delta = new int[][] {{0,1},{0,0},{0,-1}};
    public int shots = 0;
    public int moves = 0;


    //Constructor requires an Input
    public Map(Inputs input){
       getMines(input);
       mapDimension = input.mapDims;
       getCommands(input);
    }

    //get initial list of mines from Input and save to mineArrayList
    public void getMines(Inputs input){
        mineArrayList = input.generateMineList(input.fields1);
    }

    //get starting command list generated by Input
    public void getCommands(Inputs input){
       commandArrayList = input.generateCommandList();
    }

    //build map and output
    public void printMap(){
        mapDimension = newMapDimensions();
        Ship.centerShip(mapDimension);   //centers the ship on the new dimensions
        //System.out.println("Map dims: " + Arrays.toString(mapDimension));

        //create character array for map
        char[][] newMap = new char[mapDimension[1]][mapDimension[0]];
        for(int i = 0; i < newMap.length; i++){
            Arrays.fill(newMap[i],'.'); //fills the map with '.'
        }

        //get all the mine characters and generate map
        for(Mine mine:mineArrayList){
            if(!mine.destroyed) {
                //need to print mine in the spot relative to center
                newMap[mine.getCoords()[1] + Ship.getCoords()[1]][mine.getCoords()[0] + Ship.getCoords()[0]] = mine.getChar();
            }
        }

        //print map to console
        for(char[] lineY: newMap){  //goes through each char array in newMap, which = y-coord
            for(char c: lineY){     //goes through each char in a char array, which = x-coord
                System.out.print(c);
            }
            System.out.print("\n");
        }
    }

    public int[] newMapDimensions(){
        //gets dimensions for the map based on the mines relative to center
        int[] out = new int[2];

        //get min/max of x and y from mines
        for(Mine mine:mineArrayList){
            if(!mine.destroyed) {
                //I need 2x the maximum distance from the ship rounded to nearest odd number

                //if the X is less than temp min or greater than max, set
                if (Math.abs(mine.getCoords()[0]) > out[0]) out[0] = Math.abs(mine.getCoords()[0]);

                //if the Y is less than temp min or greater than max, set
                if (Math.abs(mine.getCoords()[1]) > out[1]) out[1] = Math.abs(mine.getCoords()[1]);
            }
        }

        //Set dimensions to be an odd number so that ship can be centered properly
        out[0] *= 2;
        if(out[0]%2 == 0){
            out[0]+=1;
        }
        out[1] *= 2;
        if(out[1]%2 == 0){
            out[1]+=1;
        }

        return out; //return an {x,y}
    }

    public void doAllCommands(){
        Boolean extraCommands = false;
        int stepCount = 1; //initialize stepcount to first step. A step is an actual command (not iterate).
        for(int i = 0; i < commandArrayList.size(); i++){

            //get command
            String command = commandArrayList.get(i);

            //pre-command printing
            if (command != "Increment") {
                System.out.println("Step " + stepCount);
                System.out.println();
                printMap();
                System.out.println();
            }

            commandDetails(command); //do the command

            //should only print after an iterate step.
            if (command != "Increment") {
                System.out.print(command);
                //checkMines returns true if we're all good, false if a mine was passed.
                if (!checkMines()) {
                    printMap();
                    break; //breaks out of the for loop to end the process there and announce failure
                }

                //check to see if next command is iterate or if this is the last command
                //if there is another command to do after this one that is not iterate, do it and increase counter
                //Needs to operate ONLY if the next command is not Iterate.
                while( (i+1) != commandArrayList.size() && commandArrayList.get(i+1) != "Increment" ){
                    i++;
                    command = commandArrayList.get(i);
                    commandDetails(command); //does the command without printing map yep
                    //checkMines returns true if we're all good, false if a mine was passed.
                    if (!checkMines()) {
                        break; //breaks out of the for loop to end the process there and announce failure
                    }
                    System.out.print(" " + command);
                }

            } else { //will run this block if the step is Increment
                stepCount++;
                if (checkAllDestroyed()) {  //if all the mines are destroyed, display a dot and break out of the for loop
                    extraCommands = (i != commandArrayList.size() - 1); //true if i not equal to last command, false if last command
                    System.out.println(" \n.");
                    System.out.println();
                    break;
                } else {
                    //print post-command map
                    System.out.println("\n");
                    printMap();
                    System.out.println();
                }
            }

        }
        //After all the commands are done, do scoring
        int finalScore = scoreFile(extraCommands);
        switch (finalScore){
            case 0: System.out.println("Fail (0)");
            break;
            default: System.out.println("Pass (" + finalScore + ")");
            break;
        }
    }

    public void commandDetails(String commIn){
                switch (commIn) {   //do the command
                    //cases for movement
                    case "North":
                        //ship moves up, all mines move down one relatively
                        for(Mine mine: mineArrayList) {
                            mine.incrementY();
                        }
                        moves++;
                        break;
                    case "South":
                        //ship moves down, all mines move up one relatively
                        for(Mine mine: mineArrayList) {
                            mine.decrementY();
                        }
                        moves++;
                        break;
                    case "East":
                        //ship moves right, all mines move left one relatively
                        for(Mine mine: mineArrayList) {
                            mine.decrementX();
                        }
                        moves++;
                        break;
                    case "West":
                        //ship moves left, all mines move right one relatively
                        for(Mine mine: mineArrayList) {
                            mine.incrementX();
                        }
                        moves++;
                        break;

                    case "Alpha":
                        for(int[] i: alpha){
                            destroyMines(i);
                        }
                        shots++;
                        break;
                    case "Beta":
                        for(int[] i: beta){
                            destroyMines(i);
                        }
                        shots++;
                        break;
                    case "Delta":
                        for(int[] i: delta){
                            destroyMines(i);
                        }
                        shots++;
                        break;
                    case "Gamma":
                        for(int[] i: gamma){
                            destroyMines(i);
                        }
                        shots++;
                        break;

                    //case for when a line of commands is done
                    case "Increment":
                        decrementMines();
                        break;
        }
    }

    //Method to take in an int[] array of (starfleet.Ship) coordinates and compare them to all mines, destroying matches
    public void destroyMines(int[] missileCoords){
        for(Mine mine: mineArrayList){
            if(Arrays.equals(mine.getCoords(), missileCoords)){
                mine.destroyMine();
            }
        }
    }

    //Check mines for passed.
    public boolean checkMines(){
        Boolean pass = true;

        for(Mine mine:mineArrayList){
            pass = mine.checkPassed();
            if(!pass){
                break;
            }
        }

        return pass;
    }

    public boolean checkAllDestroyed(){
        Boolean pass = true;

        for(Mine mine:mineArrayList){
            pass = mine.destroyed;

            if(!pass){ break;} //if a mine is false (not destroyed), break
        }

        return pass;
    }

    //Decrement Z's of mines
    public void decrementMines(){
        for(Mine mine:mineArrayList){
            mine.decrementZ();
        }
    }

    public int scoreFile(Boolean extra){
        //requires an array of mines in various states, returns a score value
        int score = 10* mineArrayList.size();
        if ( !checkMines() ){ //if a mine is passed, fail
            score = 0;
            return score;
        } else if( !checkAllDestroyed() ){  //now check that all mines are destroyed
            score = 0;
            return score;
        } else {
            int shotsRemaining = 5*mineArrayList.size();
            int movesRemaining = 3*mineArrayList.size();
            //shots fired = 5*number fired, up to 5 times number of mines
            //compare shots to shotsRemaining and take the smaller one
            int shotsPenalty = Math.min(5*shots,shotsRemaining);
            score -= shotsPenalty;
            //moves done = 2*number moves, up to 3 times number of mines
            //compare moves to movesRemaining and take the smaller one
            int movesPenalty = Math.min(3*moves,movesRemaining);
            score -= movesPenalty;
            if(extra){ //if there are extra moves, return a score of 1 regardless of other calculations
                score = 1;
            }
            return Math.max(score,1);   //minimum score of 1 for passing
        }



    }


}
